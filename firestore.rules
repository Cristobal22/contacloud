/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a hybrid security model, combining user-based access control for personal settings and role-based access control for company data.
 *
 * Data Structure:
 * - /users/{userId}:  User profile information.  Accessible only by the user and potentially admins.
 * - /companies: Companies managed by the platform.  Access is likely role-based (Admin, Accountant) via denormalized companyIds in user profiles.
 * - /companies/{companyId}/...:  Data related to a specific company (accounts, vouchers, etc.). Accessible by users associated with that company.
 * - /users/{userId}/account-groups, /users/{userId}/institutions, etc.: User-specific settings and configurations.
 *
 * Key Security Decisions:
 * - User profiles are strictly private; only the authenticated user (and potentially admins) can read or write their profile.
 * - Company listing is not explicitly denied, implying a need for a secure `list` operation, likely based on user roles.
 * - Subcollections under `/companies/{companyId}` are secured based on company membership.
 * - Ambiguous relationships default to the most secure interpretation: owner-only access.
 *
 * Denormalization for Authorization:
 * - To avoid costly `get()` operations, it's assumed user profile documents contain a `companyIds` array (or similar) listing the IDs of the companies the user is associated with. This enables efficient authorization checks for company-related data.
 *
 * Structural Segregation:
 * - User-specific settings (account groups, institutions, etc.) are stored in separate, private subcollections under `/users/{userId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner of the document.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user is associated with the specified companyId.  This function assumes
     * that the user's profile document (`/users/{userId}`) contains a `companyIds` array.
     */
    function isAuthorizedForCompany(companyId) {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.companyIds.hasAny([companyId]);
    }

    /******************** User Profile Rules ********************/

    /**
     * @description Manages access to user profile documents.
     * @path /users/{userId}
     * @allow (get) Authenticated user reading their own profile. (auth.uid = 'user123', userId = 'user123')
     * @allow (create) Authenticated user creating their own profile. (auth.uid = 'user123', userId = 'user123')
     * @allow (update) Authenticated user updating their own profile. (auth.uid = 'user123', userId = 'user123')
     * @allow (delete) Authenticated user deleting their own profile. (auth.uid = 'user123', userId = 'user123')
     * @deny (get) Authenticated user reading another user's profile. (auth.uid = 'user456', userId = 'user123')
     * @deny (create) Authenticated user creating another user's profile. (auth.uid = 'user456', userId = 'user123')
     * @deny (update) Authenticated user updating another user's profile. (auth.uid = 'user456', userId = 'user123')
     * @deny (delete) Authenticated user deleting another user's profile. (auth.uid = 'user456', userId = 'user123')
     * @principle Enforces strict user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /******************** Company Rules ********************/

    /**
     * @description Manages access to company documents.
     * @path /companies
     * @allow (get) Any authenticated user can read company information.
     * @allow (list) Any authenticated user can list companies.
     * @deny (create) No user can create companies.
     * @deny (update) No user can update company details.
     * @deny (delete) No user can delete companies.
     * @principle Restricts company creation, updates, and deletion to prevent unauthorized modification.  Read access is public.
     */
    match /companies {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /******************** Company Subcollection Rules ********************/

    /**
     * @description Manages access to subcollections of a company (accounts, vouchers, subjects, cost-centers, employees, purchases, sales, fees).
     * @path /companies/{companyId}/{collectionId}/{documentId}
     * @allow (get) Authenticated users associated with the company can read data. (auth.uid = 'user123', companyId = 'companyABC')
     * @allow (list) Authenticated users associated with the company can list data. (auth.uid = 'user123', companyId = 'companyABC')
     * @allow (create) Authenticated users associated with the company can create data. (auth.uid = 'user123', companyId = 'companyABC')
     * @allow (update) Authenticated users associated with the company can update data. (auth.uid = 'user123', companyId = 'companyABC')
     * @allow (delete) Authenticated users associated with the company can delete data. (auth.uid = 'user123', companyId = 'companyABC')
     * @deny (get) Authenticated users NOT associated with the company cannot read data. (auth.uid = 'user456', companyId = 'companyABC')
     * @deny (create) Authenticated users NOT associated with the company cannot create data. (auth.uid = 'user456', companyId = 'companyABC')
     * @principle Enforces company-based access control for all company-related data.
     */
    match /companies/{companyId}/{collectionId}/{documentId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

    /**
     * @description Manages access to the accounts subcollection of a company
     * @path /companies/{companyId}/accounts
     */
    match /companies/{companyId}/accounts/{accountId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

      /**
     * @description Manages access to the vouchers subcollection of a company
     * @path /companies/{companyId}/vouchers
     */
    match /companies/{companyId}/vouchers/{voucherId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

      /**
     * @description Manages access to the subjects subcollection of a company
     * @path /companies/{companyId}/subjects
     */
    match /companies/{companyId}/subjects/{subjectId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

    /**
     * @description Manages access to the cost-centers subcollection of a company
     * @path /companies/{companyId}/cost-centers
     */
    match /companies/{companyId}/cost-centers/{costCenterId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

    /**
     * @description Manages access to the employees subcollection of a company
     * @path /companies/{companyId}/employees
     */
    match /companies/{companyId}/employees/{employeeId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }
    
    /**
     * @description Manages access to the purchases subcollection of a company
     * @path /companies/{companyId}/purchases
     */
    match /companies/{companyId}/purchases/{purchaseId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

    /**
     * @description Manages access to the sales subcollection of a company
     * @path /companies/{companyId}/sales
     */
    match /companies/{companyId}/sales/{saleId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

   /**
     * @description Manages access to the fees subcollection of a company
     * @path /companies/{companyId}/fees
     */
    match /companies/{companyId}/fees/{feeId} {
      allow get: if isAuthorizedForCompany(companyId);
      allow list: if isAuthorizedForCompany(companyId);
      allow create: if isAuthorizedForCompany(companyId) && request.resource.data.companyId == companyId;
      allow update: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
      allow delete: if isAuthorizedForCompany(companyId) && resource.data.companyId == companyId && resource != null;
    }

    /******************** User-Specific Collection Rules ********************/

    /**
     * @description Manages access to user-specific collections (account-groups, institutions, family-allowance-parameters, tax-parameters, health-entities, afp-entities).
     * @path /users/{userId}/{collectionId}/{documentId}
     * @allow (get) Owner can read their own data. (auth.uid = 'user123', userId = 'user123')
     * @allow (list) Owner can list their own data. (auth.uid = 'user123', userId = 'user123')
     * @allow (create) Owner can create data in their own collection. (auth.uid = 'user123', userId = 'user123')
     * @allow (update) Owner can update data in their own collection. (auth.uid = 'user123', userId = 'user123')
     * @allow (delete) Owner can delete data from their own collection. (auth.uid = 'user123', userId = 'user123')
     * @deny (get) Non-owner cannot read the data. (auth.uid = 'user456', userId = 'user123')
     * @deny (create) Non-owner cannot create data in this collection. (auth.uid = 'user456', userId = 'user123')
     * @principle Enforces strict user-ownership for user-specific data.
     */
    match /users/{userId}/{collectionId}/{documentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to the account-groups subcollection of a user
     * @path /users/{userId}/account-groups
     */
    match /users/{userId}/account-groups/{accountGroupId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to the institutions subcollection of a user
     * @path /users/{userId}/institutions
     */
    match /users/{userId}/institutions/{institutionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to the family-allowance-parameters subcollection of a user
     * @path /users/{userId}/family-allowance-parameters
     */
    match /users/{userId}/family-allowance-parameters/{familyAllowanceParameterId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages access to the tax-parameters subcollection of a user
     * @path /users/{userId}/tax-parameters
     */
    match /users/{userId}/tax-parameters/{taxParameterId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Manages access to the health-entities subcollection of a user.
      * @path /users/{userId}/health-entities
      */
     match /users/{userId}/health-entities/{healthEntityId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
     }

    /**
     * @description Manages access to the afp-entities subcollection of a user.
     * @path /users/{userId}/afp-entities
     */
    match /users/{userId}/afp-entities/{afpEntityId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }
  }
}